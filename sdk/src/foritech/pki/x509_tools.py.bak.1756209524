from __future__ import annotations
import base64, json
from datetime import datetime, timedelta, timezone
from typing import Tuple, Optional

from cryptography import x509
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.x509.oid import NameOID, ObjectIdentifier
from cryptography.x509 import UnrecognizedExtension

# Частен OID (временен до PEN/регистрация)
OID_FORITECH_HYBRID = ObjectIdentifier("1.3.6.1.4.1.55555.1.1")

def _now_utc() -> datetime:
    return datetime.now(tz=timezone.utc)

def generate_hybrid_selfsigned(
    cn: str,
    kem_name: str,
    pqc_pubkey_bytes: bytes,
    days_valid: int = 365,
) -> Tuple[bytes, bytes]:
    """
    Генерира self-signed ECDSA P-256 сертификат + PQC KEM публичен ключ в custom X.509 extension.
    Връща (cert_pem, privkey_pem).
    """
    # Класически ключ (ECDSA)
    priv = ec.generate_private_key(ec.SECP256R1())
    pub = priv.public_key()

    subject = issuer = x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, cn)])
    not_before = _now_utc() - timedelta(minutes=1)
    not_after  = not_before + timedelta(days=days_valid)

    # Payload за хибридния extension (JSON като raw bytes)
    ext_payload = {
        "kem": kem_name,
        "pqc_pub_b64": base64.b64encode(pqc_pubkey_bytes).decode("ascii"),
        "format": "raw",  # TODO: бъдещо SPKI/oqs-json
        "v": 1,
    }
    ext_bytes = json.dumps(ext_payload, separators=(",", ":")).encode("utf-8")
    hybrid_ext = UnrecognizedExtension(OID_FORITECH_HYBRID, ext_bytes)

    builder = (
        x509.CertificateBuilder()
        .subject_name(subject)
        .issuer_name(issuer)
        .public_key(pub)
        .serial_number(x509.random_serial_number())
        .not_valid_before(not_before)
        .not_valid_after(not_after)
        .add_extension(x509.BasicConstraints(ca=False, path_length=None), critical=True)
        .add_extension(hybrid_ext, critical=False)
    )
    cert = builder.sign(private_key=priv, algorithm=hashes.SHA256())

    cert_pem = cert.public_bytes(encoding=serialization.Encoding.PEM)
    key_pem = priv.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption(),
    )
    return cert_pem, key_pem

def extract_hybrid_info(cert_pem: bytes) -> Optional[dict]:
    """
    Чете нашия custom extension и връща dict или None, ако липсва.
    Формат: {"kem": "...", "pqc_pub_b64": "...", "format":"raw", "v":1}
    """
    cert = x509.load_pem_x509_certificate(cert_pem)
    try:
        ext = cert.extensions.get_extension_for_oid(OID_FORITECH_HYBRID).value
    except x509.ExtensionNotFound:
        return None
    if isinstance(ext, UnrecognizedExtension):
        try:
            return json.loads(ext.value.decode("utf-8"))
        except Exception:
            return None
    return None
